#pragma kernel GetMotionVector
#pragma kernel GenerateMipmap
#pragma kernel BackwardSearch

RWTexture2D<float> ForwardWarpingDepthTexture;
RWTexture2D<float4> MotionVector;
Texture2D<float> PrevDepthTexture;
float4x4 PrevProjectionMatrix;
float4x4 InversedPrevProjectionViewMatrix;
float4x4 CurrentProjectionViewMatrix;
float FarClipPlane, NearClipPlane;

RWTexture2D<float4> MotionTextureSrc;
RWTexture2D<float4> MotionTextureDst;
int SrcLevel;

RWTexture2D<float> BackwardWarpingDepthTexture;
Texture2D<float4> MipmapmotionVectorsTexture;
SamplerState sampler_linear_clamp;
int MaxMipmapLevel;

[numthreads(8, 8, 1)]
void GetMotionVector(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    PrevDepthTexture.GetDimensions(width, height);
    if (id.x >= width || id.y >= height) return;

    float depth = -PrevProjectionMatrix[2][2] + PrevProjectionMatrix[2][3] / ((FarClipPlane * NearClipPlane) / (NearClipPlane + PrevDepthTexture[id.xy] * (FarClipPlane - NearClipPlane)));
    float4 clipSpacePos = float4(
        (float)id.x / width * 2.0 - 1.0,
        (float)id.y / height * 2.0 - 1.0,
        depth,                            
        1.0                            
    );
    
    float4 worldPos = mul(InversedPrevProjectionViewMatrix, clipSpacePos);
    worldPos /= worldPos.w;
    ForwardWarpingDepthTexture[id.xy] = worldPos;
    float4 currentClipPos = mul(CurrentProjectionViewMatrix, worldPos);
    currentClipPos /= currentClipPos.w;
    
    float2 currentPixel = float2(
        (currentClipPos.x + 1.0) * 0.5 * width,
        (currentClipPos.y + 1.0) * 0.5 * height
    );
    
    float2 diff = currentPixel - float2(id.x, id.y);
    ForwardWarpingDepthTexture[id.xy] = currentClipPos.z;
    MotionVector[id.xy] = float4(diff, diff);
}

[numthreads(8, 8, 1)]
void GenerateMipmap(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    MotionTextureDst.GetDimensions(width, height);
    if (id.x >= width || id.y >= height) return;
    int srcX = id.x * 2;
    int srcY = id.y * 2;
    float4 val0 = MotionTextureSrc[int2(srcX, srcY)];
    float4 val1 = MotionTextureSrc[int2(srcX + 1, srcY)];
    float4 val2 = MotionTextureSrc[int2(srcX, srcY + 1)];
    float4 val3 = MotionTextureSrc[int2(srcX + 1, srcY + 1)];
    float2 minXY = min(min(val0.xy, val1.xy), min(val2.xy, val3.xy));
    float2 maxZW = max(max(val0.zw, val1.zw), max(val2.zw, val3.zw));
    MotionTextureDst[id.xy] = float4(minXY, maxZW);
}

[numthreads(8, 8, 1)]
void BackwardSearch(uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    BackwardWarpingDepthTexture.GetDimensions(width, height);
    if (id.x >= width || id.y >= height) return;

    float2 uv = float2(0, 0);
    float4 color = MipmapmotionVectorsTexture.SampleLevel(sampler_linear_clamp, uv, MaxMipmapLevel);
    BackwardWarpingDepthTexture[id.xy] = color.g;
}